{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"bits stdcpp bp": {
		"prefix": "boilerplate c++",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <cmath>",
			"using namespace std;",
			"#define endl '\\n'",
			"#define vint vector<int>",
			"#define uset unordered_set",
			"#define umap unordered_map",
			"#define vbool vector<bool>",
			"#define vvint vector<vector<int>>",
			"#define ll long long",
			"#define MOD 1000000007",
			"// powint unionfn kmplps ncr findprimes cceil",
			"// sqrtl()\n",
			"int main()",
			"{",
				"\tios_base::sync_with_stdio(0);",
				"\tcin.tie(0);",
				"\tcout.tie(0);",
				"\t$1",
				"\treturn 0;",
			"}",
		],
		"description": "cpp boilerplate codes"
	},
	"power fn": {
		"prefix": "powint",
		"body": [
			"int power(int base, int exponent)",
			"{",
				"\tif (exponent == 0)",
				"\t\treturn 1;",
				"\tint result = 1;",
				"\twhile (exponent > 0)",
				"\t{",
				"\t\tif (exponent % 2 == 1)",
				"\t\t\tresult *= base;",
				"\t\tbase *= base;",
				"\t\texponent /= 2;",
				"\t}",
				"\treturn result;",
			"}"
		],
		"description": "power function for int"
	},
	"union fn": {
		"prefix": "unionfn",
		"body": [
			"class UnionFind",
			"{",
			"public:",
				"\tUnionFind(int n)",
				"\t{",
					"\t\tsize.resize(n);",
					"\t\tparent.resize(n);",
					"\t\tfor (int i = 0; i < n; i++)",
					"\t\t{",
						"\t\t\tparent[i] = i; // Initialize each element as its own parent",
						"\t\t\tsize[i] = 1; // Initially, each subset has one element",
					"\t\t}",
				"\t}\n",
				"\tint find(int x)",
				"\t{",
					"\t\tif (parent[x] == x)",
						"\t\t\treturn x;",
					"\t\treturn parent[x] = find(parent[x]); // path compression",
				"\t}\n",
				"\tvoid merge(int x, int y)",
				"\t{",
					"\t\tint rootX = find(x);",
					"\t\tint rootY = find(y);\n",
					"\t\tif (rootX != rootY)",
					"\t\t{",
						"\t\t\t// Merge the smaller-sized tree into the larger-sized tree",
						"\t\t\tif (size[rootX] <= size[rootY])",
						"\t\t\t{",
							"\t\t\t\tparent[rootX] = rootY;",
							"\t\t\t\tsize[rootY] += size[rootX];",
						"\t\t\t}\n",
						"\t\t\telse if (size[rootX] > size[rootY])",
						"\t\t\t{",
							"\t\t\t\tparent[rootY] = rootX;",
							"\t\t\t\tsize[rootX] += size[rootY];",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tbool isConnected(int x, int y)",
				"\t{",
					"\t\t// Check if elements x and y belong to the same set",
					"\t\treturn find(x) == find(y);",
				"\t}",
			"private:",
				"\tvector<int> parent;",
				"\tvector<int> size;",
			"};",
		],
		"description": "union fn for graph"
	},
	"kmp fn": {
		"prefix": "kmplps",
		"body": [
			"void kmp(string s) // lps O(n)"
			"{",
				"\t// string s;",
				"\t// cin >> s;",
				"\tint n = s.length();",
				"\tvint lps(n + 1);",
				"\tint i = 0, j = -1;",
				"\tlps[0] = -1;",
				"\twhile (i < n)",
				"\t{",
					"\t\twhile (j != -1 && s[j] != s[i])",
					"\t\t\tj = lps[j];",
					"\t\ti++;",
					"\t\tj++;",
					"\t\tlps[i] = j;",
    			"\t}",
    			"\tfor (int i = 1; i <= n; i++)",
        			"\t\tcout << lps[i] << \" \";",
    			"\tcout << endl;",
			"}"
		],
		"description": "kmp lps function"
	},
	"n choose r": {
		"prefix": "ncr",
		"body": [
			"int nChooseR(int n, int r)",
			"{",
    			"\tunsigned long long sum = 1;",
    			"\t// Calculate the value of n choose r using the binomial coefficient formula",
    			"\tfor (int i = 0; i < r; i++)",
    			"\t{",
        			"\t\tsum *= (n - i);",
        			"\t\tsum /= (i + 1);",
    			"\t}",
    			"\tint ans = sum % MOD;",
    			"\treturn ans;",
			"}"
		],
		"description": "ncr function"
	},
	"sieveOfEratosthenes": {
		"prefix": "findprimes",
		"body": [
			"// O(nlog(logn))",
			"vint noOfPrimes(int n)",
			"{",
    			"\tvint isPrime(n + 1, 1); // from 2 to n its storing prime number",
    			"\tfor (int i = 2; i <= n; i++)",
        			"\t\tif (isPrime[i])",
            			"\t\t\tfor (ll j = 1LL * i * i; j <= n; j += i)",
                			"\t\t\t\tisPrime[j] = 0;",
    			"\tvint primes;",
    			"\tfor (int i = 2; i <= n; i++)",
        			"\t\tif (isPrime[i])",
            			"\t\t\tprimes.push_back(i);",
    			"\treturn primes;",
			"}"
		],
		"description": "finding primes from 2 to n"
	},
	"comp prog boiler": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <cmath>",
			"using namespace std;",
			"#define endl '\\n'",
			"#define vint vector<int>",
			"#define uset unordered_set",
			"#define umap unordered_map",
			"#define vbool vector<bool>",
			"#define vvint vector<vector<int>>",
			"#define ll long long",
			"#define MOD 1000000007",
			"// powint unionfn kmplps ncr findprimes cceil",
			"// sqrtl()\n",
			"int main()",
			"{",
				"\tios_base::sync_with_stdio(0);",
				"\tcin.tie(0);",
				"\tcout.tie(0);",
				"\tint t;",
    			"\tcin >> t;",
    			"\twhile (t--)"
    			"\t{\n\t\t$1",
    			"\t}",
				"\treturn 0;",
			"}",
		],
		"description": "cp boiler"
	},
	"custom ceil fn": {
		"prefix": "cceil",
		"body": [
			"ll myCeil(ll num, ll den)",
			"{",
			"\tll ans = 1LL * (num + den - 1) / den;",
			"\treturn ans;",
			"}",
		],
		"description": "my ceil fun"
	}
}